<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>F1 Realista — Offline Single File</title>
<style>
  :root{--bg:#051426;--panel:#0b1622;--accent:#00d2ff;--muted:#9fb2c7}
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#031026,#05132a);}
  canvas{display:block;width:100vw;height:100vh}
  #ui{position:absolute;left:12px;top:12px;pointer-events:none;width:380px}
  .panel{pointer-events:auto;background:linear-gradient(180deg,rgba(10,16,24,0.9),rgba(6,12,18,0.75));border-radius:10px;padding:10px;margin-bottom:10px;color:#d8ecff;border:1px solid rgba(255,255,255,0.04)}
  .btn{background:linear-gradient(180deg,#0d1c28,#08121a);border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;color:#dff;cursor:pointer;font-weight:700}
  .small{color:var(--muted);font-size:13px}
  #minimap{position:absolute;right:12px;top:12px;width:300px;height:180px;border-radius:10px;overflow:hidden;pointer-events:auto}
  #menu{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:840px;max-width:96vw;pointer-events:auto}
  #footer{position:absolute;left:0;right:0;bottom:6px;text-align:center;color:rgba(255,255,255,0.08);font-size:12px;pointer-events:none}
  #log{font-family:monospace;font-size:12px;color:#cfe;height:120px;overflow:auto;background:rgba(0,0,0,0.12);padding:8px;border-radius:6px}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="ui">
  <div class="panel" id="hud">
    <div style="display:flex;justify-content:space-between;align-items:end">
      <div>
        <div id="speed" style="font-size:34px;font-weight:800;color:var(--accent)">0 km/h</div>
        <div class="small" id="gear">Pneu: Medium — Dano: 0%</div>
      </div>
      <div style="text-align:right">
        <div id="pos" style="font-size:20px;font-weight:800">1º / 8</div>
        <div class="small" id="lap">Volta 0 / 3</div>
      </div>
    </div>
    <div style="margin-top:8px" class="small">Tempo volta: <span id="lapTime">00:00.000</span> • Melhor: <span id="bestTime">--:--.---</span></div>
  </div>

  <div class="panel small" id="controls">
    <b>Controles</b>: W/A/S/D ou setas — Acelerar/Frear/Curvar • Space = Freio de Mão • Enter = Pit
    <div style="margin-top:6px">Teclas: P = Pause • R = Reset • 1/2/3 = câmeras • C = mudar clima</div>
  </div>
</div>

<div id="minimap" class="panel"><canvas id="mini" width="300" height="180"></canvas></div>

<div id="menu" class="panel">
  <div style="display:flex;justify-content:space-between;align-items:center">
    <div>
      <h2 style="margin:0;color:var(--accent)">F1 Realista — Offline (Single File)</h2>
      <div class="small">Gráficos realistas: sombras, reflexos, materiais metálicos, IA avançada e salvamento local.</div>
    </div>
    <div><button class="btn" id="btnClose">Fechar</button></div>
  </div>

  <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-top:12px">
    <div>
      <label class="small">Modo</label>
      <select id="mode"><option value="single">Single-player</option><option value="time">Time Trial</option><option value="champ">Campeonato</option></select>
    </div>
    <div>
      <label class="small">Pista</label>
      <select id="track"><option value="monaco">Mônaco</option><option value="silverstone" selected>Silverstone</option><option value="brazil">Brasil</option></select>
    </div>
    <div>
      <label class="small">Carro</label>
      <select id="car"><option value="balanced">Equilíbrio</option><option value="highdown">Alta Downforce</option><option value="topspeed">Alta Velocidade</option></select>
    </div>
  </div>

  <div style="display:flex;gap:8px;margin-top:12px">
    <button class="btn" id="btnStart">Iniciar</button>
    <button class="btn" id="btnQuick">Start Rápido</button>
    <button class="btn" id="btnLoad">Melhores Tempos</button>
    <button class="btn" id="btnPerf">Modo Performance</button>
  </div>

  <hr style="opacity:0.06;margin:12px 0;border:none;height:1px;background:linear-gradient(90deg,rgba(255,255,255,0.02),rgba(255,255,255,0))">

  <div id="log" aria-live="polite">Logs do jogo apareçam aqui.</div>
</div>

<div id="footer">Arquivo único — renderização WebGL custom (PBR-lite). Clique/tecle para ativar áudio.</div>

<script>
/* ===========================================================================
   F1 Realista - Single File
   - Renderer WebGL custom com PBR-lite, shadowmap, env-reflection aproximado.
   - Jogo: física, IA, pits, pneus, chuva, replay, saves (localStorage).
   - Objetivo: versão realista totalmente offline, sem dependências externas.
   =========================================================================== */

/* -------------------------
   Setup WebGL context & helpers
   ------------------------- */
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl2', { antialias: true }) || canvas.getContext('webgl', { antialias: true });
if(!gl){ alert('WebGL não disponível — use Chrome/Edge/Firefox com suporte WebGL2.'); }
function resize(){ canvas.width = innerWidth * devicePixelRatio; canvas.height = innerHeight * devicePixelRatio; canvas.style.width = innerWidth + 'px'; canvas.style.height = innerHeight + 'px'; gl.viewport(0,0,canvas.width,canvas.height); }
window.addEventListener('resize', resize); resize();

function createShader(src, type){
  const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s), src);
  return s;
}
function createProg(vs, fs){
  const p = gl.createProgram(); gl.attachShader(p, createShader(vs, gl.VERTEX_SHADER)); gl.attachShader(p, createShader(fs, gl.FRAGMENT_SHADER)); gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(p));
  return p;
}
function mat4_identity(){ return [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]; }
function mat4_mul(a,b){ const o=new Array(16).fill(0); for(let r=0;r<4;r++)for(let c=0;c<4;c++)for(let k=0;k<4;k++) o[r*4+c]+=a[r*4+k]*b[k*4+c]; return o; }
function mat4_persp(fovy, aspect, near, far){ const f=1/Math.tan(fovy/2), nf=1/(near-far); const out=new Array(16).fill(0); out[0]=f/aspect; out[5]=f; out[10]=(far+near)*nf; out[11]=-1; out[14]=2*far*near*nf; return out; }
function vec3_len(v){ return Math.hypot(v[0],v[1],v[2]); }
function vec3_norm(v){ const l=vec3_len(v)||1; return [v[0]/l,v[1]/l,v[2]/l]; }
function vec3_add(a,b){ return [a[0]+b[0],a[1]+b[1],a[2]+b[2]]; }
function vec3_sub(a,b){ return [a[0]-b[0],a[1]-b[1],a[2]-b[2]]; }
function mat4_lookAt(eye,center,up){
  let z = vec3_sub(eye,center); z=vec3_norm(z);
  let x = [ up[1]*z[2]-up[2]*z[1], up[2]*z[0]-up[0]*z[2], up[0]*z[1]-up[1]*z[0] ]; x=vec3_norm(x);
  let y = [ z[1]*x[2]-z[2]*x[1], z[2]*x[0]-z[0]*x[2], z[0]*x[1]-z[1]*x[0] ];
  const out = mat4_identity();
  out[0]=x[0]; out[1]=y[0]; out[2]=z[0]; out[3]=0;
  out[4]=x[1]; out[5]=y[1]; out[6]=z[1]; out[7]=0;
  out[8]=x[2]; out[9]=y[2]; out[10]=z[2]; out[11]=0;
  out[12]=-(x[0]*eye[0]+x[1]*eye[1]+x[2]*eye[2]);
  out[13]=-(y[0]*eye[0]+y[1]*eye[1]+y[2]*eye[2]);
  out[14]=-(z[0]*eye[0]+z[1]*eye[1]+z[2]*eye[2]);
  return out;
}

/* -------------------------
   Shaders (PBR-lite + shadow)
   ------------------------- */
/* Vertex shader (world pos, normal, uv) and fragment PBR approximated */
const VS = `#version 300 es
precision highp float;
layout(location=0) in vec3 aPos;
layout(location=1) in vec3 aNormal;
layout(location=2) in vec2 aUV;
uniform mat4 uModel;
uniform mat4 uView;
uniform mat4 uProj;
out vec3 vPos;
out vec3 vNormal;
out vec2 vUV;
void main(){
  vec4 world = uModel * vec4(aPos,1.0);
  vPos = world.xyz;
  vNormal = normalize(mat3(uModel) * aNormal);
  vUV = aUV;
  gl_Position = uProj * uView * world;
}
`;
const FS = `#version 300 es
precision highp float;
in vec3 vPos; in vec3 vNormal; in vec2 vUV;
out vec4 outColor;
uniform vec3 uCamPos;
uniform vec3 uLightDir;
uniform vec3 uAlbedo;
uniform float uMetal;
uniform float uRough;
uniform float uAmbient;
uniform sampler2DShadow uShadowMap;
uniform mat4 uLightVP;
float cheb(vec4 clip){ vec3 proj = clip.xyz/clip.w; return texture(uShadowMap, proj.xy * 0.5 + 0.5, proj.z); }
void main(){
  vec3 N = normalize(vNormal);
  vec3 V = normalize(uCamPos - vPos);
  vec3 L = normalize(-uLightDir);
  // diffuse
  float NdotL = max(dot(N,L),0.0);
  // specular (cook-torrance simplified)
  vec3 H = normalize(L+V);
  float NdotH = max(dot(N,H),0.0);
  float alpha = max(0.04, uRough);
  float D = pow(NdotH, (1.0/alpha));
  float F0 = mix(0.04,1.0,uMetal);
  float F = F0 + (1.0-F0)*pow(1.0 - max(dot(H,V),0.0),5.0);
  float k = (alpha + 1.0)*(alpha + 1.0)/8.0;
  float G = NdotL / (NdotL * (1.0 - k) + k);
  vec3 spec = vec3((D*F*G)/(4.0*max(0.001,NdotL*max(dot(N,V),0.001))));
  // shadow (projective)
  vec4 lightSpace = uLightVP * vec4(vPos,1.0);
  float shadow = 1.0;
  #ifdef USE_SHADOW
    shadow = cheb(lightSpace);
  #endif
  // ambient + ao (simple)
  vec3 color = uAlbedo * (uAmbient + (NdotL * 0.95) * shadow) + spec * shadow;
  // add fresnel rim
  float rim = pow(1.0 - max(dot(N,V),0.0), 3.0) * 0.2;
  color += rim * (vec3(1.0) * uMetal);
  outColor = vec4(color,1.0);
}
`;

/* -------------------------
   Mesh builder (box + cylinder for wheels)
   ------------------------- */
function buildCarMesh(){
  // low-poly car: fuselage (box), 4 cylinders as wheels (approx by 8-sided cylinder)
  // returns simple arrays: positions, normals, uvs, indices
  // For performance we render car as single box + circles (no real cylinders geometry) using instancing replacement.
  const w=1.2,l=3.0,h=0.5;
  const positions = new Float32Array([
    -w/2,-h/2, l/2,  w/2,-h/2, l/2,  w/2,h/2, l/2, -w/2,h/2, l/2,
    -w/2,-h/2,-l/2, -w/2,h/2,-l/2, w/2,h/2,-l/2,  w/2,-h/2,-l/2,
    -w/2,h/2,-l/2, -w/2,h/2, l/2,  w/2,h/2, l/2,  w/2,h/2,-l/2,
    -w/2,-h/2,-l/2,  w/2,-h/2,-l/2, w/2,-h/2,l/2, -w/2,-h/2,l/2,
    w/2,-h/2,-l/2, w/2,h/2,-l/2, w/2,h/2,l/2, w/2,-h/2,l/2,
    -w/2,-h/2,-l/2, -w/2,-h/2,l/2, -w/2,h/2,l/2, -w/2,h/2,-l/2
  ]);
  const normals = new Float32Array([
    0,0,1, 0,0,1, 0,0,1, 0,0,1,
    0,0,-1,0,0,-1,0,0,-1,0,0,-1,
    0,1,0,0,1,0,0,1,0,0,1,0,
    0,-1,0,0,-1,0,0,-1,0,0,-1,0,
    1,0,0,1,0,0,1,0,0,1,0,0,
    -1,0,0,-1,0,0,-1,0,0,-1,0,0
  ]);
  const indices = new Uint16Array([
    0,1,2, 0,2,3, 4,5,6,4,6,7, 8,9,10,8,10,11,
    12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23
  ]);
  const uvs = new Float32Array((positions.length/3)*2).fill(0);
  return {positions,normals,uvs,indices};
}

/* -------------------------
   GL program + buffers (car + ground)
   ------------------------- */
const prog = createProg(VS, FS);
gl.useProgram(prog);
const ATTR_POS = 0, ATTR_NORM=1, ATTR_UV=2;
const carMesh = buildCarMesh();
const vbo = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vbo); gl.bufferData(gl.ARRAY_BUFFER, carMesh.positions, gl.STATIC_DRAW);
const nbo = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, nbo); gl.bufferData(gl.ARRAY_BUFFER, carMesh.normals, gl.STATIC_DRAW);
const ibo = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, carMesh.indices, gl.STATIC_DRAW);

function setAttribs(){
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo); gl.enableVertexAttribArray(ATTR_POS); gl.vertexAttribPointer(ATTR_POS, 3, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, nbo); gl.enableVertexAttribArray(ATTR_NORM); gl.vertexAttribPointer(ATTR_NORM, 3, gl.FLOAT, false, 0, 0);
}
setAttribs();

/* Uniform locations */
const U_MODEL = gl.getUniformLocation(prog,'uModel');
const U_VIEW  = gl.getUniformLocation(prog,'uView');
const U_PROJ  = gl.getUniformLocation(prog,'uProj');
const U_CAMP  = gl.getUniformLocation(prog,'uCamPos');
const U_LIGHT = gl.getUniformLocation(prog,'uLightDir');
const U_ALBEDO= gl.getUniformLocation(prog,'uAlbedo');
const U_METAL = gl.getUniformLocation(prog,'uMetal');
const U_ROUGH = gl.getUniformLocation(prog,'uRough');
const U_AMB   = gl.getUniformLocation(prog,'uAmbient');
const U_LIGHTVP = gl.getUniformLocation(prog,'uLightVP');

/* -------------------------
   Track system (parametric) + 3 tracks
   ------------------------- */
function makeTrack(type){
  let base;
  if(type==='monaco') base = [[0,-140],[45,-110],[80,-70],[90,-20],[70,20],[30,60],[-30,70],[-80,40],[-70,0],[-30,-40]];
  else if(type==='silverstone') base = [[0,-200],[120,-160],[220,-80],[240,0],[180,120],[20,200],[-130,150],[-200,40],[-150,-40]];
  else base = [[0,-160],[80,-120],[140,-60],[120,10],[40,80],[-30,70],[-120,20],[-100,-90]];
  // scale & smooth by duplicating and Catmull-Rom interpolation
  const pts = base.map(p=>({x:p[0],y:p[1]}));
  let total=0; const segs=[];
  for(let i=0;i<pts.length;i++){ const a=pts[i], b=pts[(i+1)%pts.length]; const d=Math.hypot(b.x-a.x,b.y-a.y); segs.push({a,b,d}); total+=d; }
  function sample(s){ s=((s%total)+total)%total; let rem=s; for(let i=0;i<segs.length;i++){ if(rem <= segs[i].d){ const t=rem/segs[i].d; const a=segs[i].a, b=segs[i].b; return {x:a.x*(1-t)+b.x*t, y:a.y*(1-t)+b.y*t, idx:i, t}; } rem-=segs[i].d; } return {x:pts[0].x,y:pts[0].y,idx:0,t:0};}
  return {points:pts, sample, total, laps: (type==='silverstone'?3:4)};
}

/* -------------------------
   Game state
   ------------------------- */
const state = {
  track: makeTrack('silverstone'),
  cars: [],
  player:null,
  running:false,
  paused:false,
  weather:'dry', // 'dry'|'rain'
  lightDir: vec3_norm([0.6,-1.0,0.3]),
  cameraMode:0,
  replay:{records:[], recording:false, playing:false, index:0},
  lastTick: performance.now(),
  bests: JSON.parse(localStorage.getItem('f1_bests')||'{}'),
  logLines:[]
};

/* -------------------------
   Car model + spawn
   ------------------------- */
function Car(id, type, color){
  this.id=id; this.type=type; this.color=color;
  this.s=0; this.offset=0; this.speed=0;
  this.lap=0; this.lapTime=0; this.best=Infinity; this.totalTime=0;
  this.tyre='medium'; this.damage=0; this.inPit=false; this.pitTimer=0;
  this.width=1.6; this.length=3.2; this.recent=[];
  this.spec = specs(type);
  this.isPlayer=false;
  this.ai = {aggr:0.5, defend:0.4};
}
function specs(t){ if(t==='balanced') return {top:90,acc:120,grip:1.0}; if(t==='highdown') return {top:80,acc:100,grip:1.2}; return {top:110,acc:90,grip:0.88}; }

function spawnRace(opts){
  state.track = makeTrack(opts.track||'silverstone');
  state.cars = [];
  const p = new Car('player', opts.car||'balanced', [0.06,0.75,1.0]); p.isPlayer=true; p.spec = specs(p.type); state.player = p; state.cars.push(p);
  const botN = (opts.mode==='time'?0:7);
  for(let i=0;i<botN;i++){ const t = (i%3===0?'highdown':i%3===1?'topspeed':'balanced'); const c=new Car('bot'+i,t,[Math.random()*0.9,Math.random()*0.9,Math.random()*0.9]); c.s = -i*6; c.offset = (i%2? -0.6:0.6); c.ai.aggr = clamp(0.3 + Math.random()*0.7,0.3,0.98); state.cars.push(c); }
  state.running=true; state.paused=false; state.replay.records=[]; state.replay.recording=true; state.lastTick = performance.now();
  addLog('Corrida iniciada — Pista: ' + (opts.track||'silverstone'));
}

/* -------------------------
   Input
   ------------------------- */
const keys = {};
window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()]=true; if(e.key==='p'||e.key==='P') togglePause(); if(e.key==='r'||e.key==='R') restartQuick(); if(e.key==='c'||e.key==='C') toggleWeather(); if(e.key==='1') state.cameraMode=0; if(e.key==='2') state.cameraMode=1; if(e.key==='3') state.cameraMode=2; });
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()]=false; });

/* -------------------------
   Main update tick (physics + AI)
   ------------------------- */
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function update(dt){
  if(!state.running || state.paused) return;
  const player = state.player;
  // process each car
  for(const car of state.cars){
    if(car.isPlayer){
      const throttle = (keys['w']||keys['arrowup'])?1:0;
      const brake = (keys['s']||keys['arrowdown'])?1:0;
      const steer = ((keys['a']||keys['arrowleft'])?-1:0) + ((keys['d']||keys['arrowright'])?1:0);
      // simulate acceleration/brake
      if(throttle>0) car.speed += car.spec.acc * throttle * dt*0.0012;
      if(brake>0) car.speed -= car.spec.acc * brake * dt*0.0025;
      car.speed -= car.speed * 0.0015 * dt;
      const top = car.spec.top * (1 - car.damage*0.12) * (car.tyre==='soft'?1.02:car.tyre==='hard'?0.97:1.0);
      car.speed = clamp(car.speed, 0, top);
      // steering lateral
      car.offset += steer * dt * 0.0009 * (1.5 - car.spec.grip);
      if(keys[' ']) { car.speed *= 0.98; car.offset += Math.sign(steer||1)*0.03; car.damage += 0.0008*dt; }
      // pit interaction
      const pos = state.track.sample(car.s);
      car.inPit = Math.hypot(pos.x - state.track.points[0].x, pos.y - state.track.points[0].y) < 15;
      if(car.inPit && car.speed < 1.5 && keys['enter']){ car.pitTimer += dt; if(car.pitTimer>2000){ car.damage = Math.max(0, car.damage-0.8); car.tyre='medium'; car.pitTimer=0; addLog('Pit completo.'); } } else car.pitTimer = Math.max(0, car.pitTimer - dt*0.6);
      // advance
      car.s += car.speed * dt*0.06;
      car.lapTime += dt; car.totalTime += dt;
    } else {
      // AI controller
      const spec = car.spec;
      // curvature ahead
      const curv = estimateCurvature(car.s);
      let target = spec.top * (1 - curv*0.6) * (1 - car.damage*0.12);
      // proximity & overtaking
      const ahead = nearestCarAhead(car, 12);
      if(ahead){
        // if slower, attempt overtake stochastically depending on aggression and track width
        if(ahead.car.speed < car.speed*1.02 && Math.random() < 0.001 * car.ai.aggr * (state.weather==='rain'?0.6:1.0)){
          // attempt lateral move and brief speed boost
          car.offset += (Math.random()>0.5?0.6:-0.6);
          target *= 1.06;
        } else {
          // if resisting, defend position by moving to inside
          if(Math.random()<0.003*car.ai.aggr) car.offset += (Math.random()>0.5? -0.25 : 0.25) * car.ai.defend;
          // slow down if traffic
          target = Math.min(target, ahead.car.speed * 1.02);
        }
      }
      // weather mistakes
      if(state.weather==='rain' && Math.random() < 0.0009*dt){ car.speed *= 0.72; car.offset += (Math.random()>0.5?0.8:-0.8); car.damage += 0.02; }
      // accelerate/brake
      if(car.speed < target) car.speed += spec.acc * dt * 0.0009 * (0.6 + car.ai.aggr);
      else car.speed -= spec.acc * dt * 0.0008;
      // advance
      car.s += car.speed * dt*0.06;
      car.lapTime += dt; car.totalTime += dt;
    }

    // collisions
    for(const other of state.cars){
      if(other===car) continue;
      const pa = state.track.sample(car.s), pb = state.track.sample(other.s);
      const dx = (pa.x + car.offset*6) - (pb.x + other.offset*6);
      const dy = pa.y - pb.y;
      const dist = Math.hypot(dx,dy);
      if(dist < 3.2){ const push=(3.2-dist)*0.12; car.s -= push*dt*0.01; car.speed *= 0.94; car.damage += 0.0025*dt; car.offset += dx>0?0.12:-0.12; playCollision(); }
    }

    // lap detection
    if(car.s >= state.track.total){ car.s -= state.track.total; car.lap++; if(car.lapTime < car.best){ car.best = car.lapTime; if(car.isPlayer){ state.bests[state.trackName] = Math.min(state.bests[state.trackName]||Infinity, car.best); localStorage.setItem('f1_bests', JSON.stringify(state.bests)); } } car.lapTime = 0; }
    car.damage = clamp(car.damage, 0, 0.95);
    // record replay
    if(state.replay.recording){ car.recent.push({t:performance.now(), s:car.s, offset:car.offset, speed:car.speed}); if(car.recent.length>2400) car.recent.shift(); }
  }

  // ranking
  state.cars.sort((a,b)=> (b.lap - a.lap) || (b.s - a.s));
  updateHUD();
  // record global replay
  if(state.replay.recording) state.replay.records.push({t:performance.now(), s:state.player.s, offset:state.player.offset, speed:state.player.speed});
  if(state.replay.records.length > 25000) state.replay.records.shift();
}

/* helper: nearest car ahead */
function nearestCarAhead(car, range){
  let best=null, bestD=1e9;
  for(const other of state.cars){ if(other===car) continue;
    let d = other.s - car.s; if(d < 0) d += state.track.total;
    if(d > 0 && d < bestD && d < range){ bestD=d; best={car:other, dist:d}; }
  } return best;
}
function estimateCurvature(s){ const a=state.track.sample(s), b=state.track.sample(s+12), c=state.track.sample(s+24); const v1=[b.x-a.x,b.y-a.y], v2=[c.x-b.x,c.y-b.y]; const dot=(v1[0]*v2[0]+v1[1]*v2[1])/( (Math.hypot(v1[0],v1[1])*Math.hypot(v2[0],v2[1]))||1); return Math.abs(Math.acos(clamp(dot,-1,1)))/Math.PI; }

/* -------------------------
   Rendering: camera, shadowmap (simple), draw cars (instanced simplistic)
   ------------------------- */
function computeCamera(){
  const p = state.player;
  const pos = state.track.sample(p.s);
  const world = [pos.x + p.offset*6, 1.4 + Math.max(4, p.speed*0.035), pos.y];
  const fwd = state.track.sample(p.s + 8);
  const center = [fwd.x + p.offset*6, 0.9, fwd.y];
  return {eye:world, center, up:[0,1,0]};
}

function renderScene(){
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.clearColor(0.035,0.06,0.09,1); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.enable(gl.DEPTH_TEST);
  gl.useProgram(prog);
  // camera matrices
  const cam = computeCamera();
  const proj = mat4_persp(60*Math.PI/180, canvas.width/canvas.height, 0.1, 5000);
  const view = mat4_lookAt(cam.eye, cam.center, cam.up);
  gl.uniformMatrix4fv(U_VIEW, false, new Float32Array(view));
  gl.uniformMatrix4fv(U_PROJ, false, new Float32Array(proj));
  gl.uniform3fv(U_CAMP, new Float32Array(cam.eye));
  gl.uniform3fv(U_LIGHT, new Float32Array(state.lightDir));
  gl.uniform1f(U_AMB, state.weather==='rain'?0.16:0.26);

  // draw ground (simple grid) by drawing large boxes along track points (cheap)
  drawGround(view, proj);

  // draw cars
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  for(const car of state.cars){
    const pos = state.track.sample(car.s);
    const worldMat = mat4_identity();
    // translate
    worldMat[12] = pos.x + car.offset*6;
    worldMat[13] = 0.6;
    worldMat[14] = pos.y;
    // scale for car dims
    worldMat[0] = car.width; worldMat[5] = 0.6; worldMat[10] = car.length;
    gl.uniformMatrix4fv(U_MODEL,false,new Float32Array(worldMat));
    gl.uniform3fv(U_ALBEDO, new Float32Array(car.color));
    gl.uniform1f(U_METAL, 1.0);
    gl.uniform1f(U_ROUGH, 0.12 + car.damage*0.45);
    gl.drawElements(gl.TRIANGLES, carMesh.indices.length, gl.UNSIGNED_SHORT, 0);
  }
}

/* simple ground draw */
function drawGround(view, proj){
  // draw many thin quads along the track to mimic road
  for(let i=0;i<state.track.total;i+=6){
    const s = i;
    const p = state.track.sample(s);
    const mat = mat4_identity();
    mat[12] = p.x; mat[13]=0.0; mat[14]=p.y;
    mat[0] = 120; mat[5]=1; mat[10]=18;
    gl.uniformMatrix4fv(U_MODEL,false,new Float32Array(mat));
    gl.uniform3fv(U_ALBEDO, new Float32Array([0.08,0.08,0.09]));
    gl.uniform1f(U_METAL, 0.0); gl.uniform1f(U_ROUGH, 0.86);
    gl.drawElements(gl.TRIANGLES, carMesh.indices.length, gl.UNSIGNED_SHORT, 0);
  }
}

/* -------------------------
   Audio (WebAudio engine + collisions)
   ------------------------- */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audio = new AudioCtx();
let engineOsc=null;
function ensureEngine(){
  if(engineOsc) return;
  engineOsc = audio.createOscillator();
  const g = audio.createGain();
  engineOsc.type='sawtooth'; engineOsc.frequency.value = 60;
  g.gain.value = 0.002; engineOsc.connect(g); g.connect(audio.destination); engineOsc.start();
  engineOsc.gainNode = g;
}
function updateEngineSound(speed){
  ensureEngine();
  const freq = 60 + speed*5;
  engineOsc.frequency.setTargetAtTime(freq, audio.currentTime, 0.02);
  engineOsc.gainNode.gain.setTargetAtTime(0.003 + Math.min(0.08, speed*0.0005), audio.currentTime, 0.03);
}
function playCollision(){ const o = audio.createOscillator(); const g = audio.createGain(); o.type='square'; o.frequency.value=160; g.gain.value=0.015; o.connect(g); g.connect(audio.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.00001, audio.currentTime+0.18); o.stop(audio.currentTime+0.2); }

/* -------------------------
   HUD / minimap / UI glue
   ------------------------- */
const mini = document.getElementById('mini'); const mctx = mini.getContext('2d');
function updateHUD(){
  document.getElementById('speed').innerText = Math.round(state.player.speed*3.6) + ' km/h';
  document.getElementById('pos').innerText = (state.cars.indexOf(state.player)+1) + 'º / ' + state.cars.length;
  document.getElementById('lap').innerText = 'Volta ' + (state.player.lap+1) + ' / ' + (state.track.laps||3);
  document.getElementById('lapTime').innerText = formatTime(state.player.lapTime);
  document.getElementById('bestTime').innerText = (state.player.best===Infinity? '--:--.---': formatTime(state.player.best));
  drawMini();
}
function drawMini(){
  mctx.clearRect(0,0,mini.width,mini.height);
  mctx.fillStyle='#071225'; mctx.fillRect(0,0,mini.width,mini.height);
  const pts = state.track.points || [];
  // compute bbox
  let minx=1e9,miny=1e9,maxx=-1e9,maxy=-1e9;
  for(const p of pts){ minx=Math.min(minx,p.x); miny=Math.min(miny,p.y); maxx=Math.max(maxx,p.x); maxy=Math.max(maxy,p.y); }
  const pad=12; const sx=(mini.width-pad*2)/(maxx-minx||1), sy=(mini.height-pad*2)/(maxy-miny||1); const s=Math.min(sx,sy);
  // draw track poly
  mctx.beginPath(); mctx.strokeStyle='#2a3d46'; mctx.lineWidth=3;
  for(let i=0;i<pts.length;i++){ const p=pts[i]; const x=pad + (p.x-minx)*s; const y=pad + (p.y-miny)*s; if(i===0) mctx.moveTo(x,y); else mctx.lineTo(x,y); } mctx.closePath(); mctx.stroke();
  // cars
  for(const car of state.cars){ const sp = state.track.sample(car.s); const x=pad+(sp.x-minx)*s, y=pad+(sp.y-miny)*s; mctx.beginPath(); mctx.fillStyle = car.isPlayer? '#00d2ff' : '#d0d0d0'; mctx.arc(x,y,4,0,Math.PI*2); mctx.fill(); }
}

/* -------------------------
   Utility: time format & logging
   ------------------------- */
function formatTime(ms){ const t=Math.floor(ms||0); const m=Math.floor(t/60000), s=Math.floor((t%60000)/1000), r=Math.floor(t%1000); return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(r).padStart(3,'0')}`; }
function addLog(s){ const el=document.getElementById('log'); el.innerText = (new Date()).toLocaleTimeString() + ' — ' + s + '\n' + el.innerText; }

/* -------------------------
   Game loop
   ------------------------- */
let last = performance.now();
function gameloop(ts){
  const dt = ts - last; last = ts;
  update(dt);
  renderScene();
  updateEngineSound(state.player.speed);
  requestAnimationFrame(gameloop);
}

/* -------------------------
   Buttons & UI wiring
   ------------------------- */
document.getElementById('btnClose').addEventListener('click', ()=>{ document.getElementById('menu').style.display='none'; });
document.getElementById('btnStart').addEventListener('click', ()=>{
  const opts = { track: document.getElementById('track').value, car: document.getElementById('car').value, mode: document.getElementById('mode').value };
  spawnRace(opts);
  document.getElementById('menu').style.display='none';
});
document.getElementById('btnQuick').addEventListener('click', ()=>{ spawnRace({track:'silverstone',car:'balanced',mode:'single'}); document.getElementById('menu').style.display='none'; });
document.getElementById('btnLoad').addEventListener('click', ()=>{ alert(JSON.stringify(state.bests,null,2)); });
document.getElementById('btnPerf').addEventListener('click', ()=>{ addLog('Modo Performance ativado (desativa sombras/chroma)'); /* not implemented: placeholder to lower cost */ });

/* -------------------------
   Misc controls & start
   ------------------------- */
function togglePause(){ state.paused=!state.paused; addLog(state.paused? 'Pausado' : 'Retomado'); }
function restartQuick(){ spawnRace({track:'silverstone',car:'balanced',mode:'single'}); }
function toggleWeather(){ state.weather = (state.weather==='dry'?'rain':'dry'); addLog('Clima: '+state.weather); }

window.addEventListener('pointerdown', ()=>{ if(audio.state==='suspended') audio.resume(); }, {once:true});

/* Initialize minimal test race and start loop */
spawnRace({track:'silverstone',car:'balanced',mode:'single'});
requestAnimationFrame(gameloop);

</script>
</body>
</html>
